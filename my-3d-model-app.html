<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>יוצר מודל תלת מימדי</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            display: grid;
            grid-template-columns: 350px 1fr;
            height: 100vh;
            gap: 20px;
            padding: 20px;
        }

        .control-panel {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            overflow-y: auto;
        }

        .viewer {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #4a5568;
            font-size: 28px;
            font-weight: 600;
        }

        .input-group {
            margin-bottom: 25px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2d3748;
            font-size: 16px;
        }

        .coordinate-inputs {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        input {
            padding: 12px 15px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: rgba(255, 255, 255, 0.8);
        }

        input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            transform: translateY(-2px);
        }

        .input-labels {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
            margin-bottom: 5px;
            font-size: 12px;
            font-weight: 500;
            color: #718096;
        }

        button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .point-list {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(247, 250, 252, 0.8);
            border-radius: 12px;
            padding: 15px;
        }

        .point-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 8px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            transition: all 0.2s ease;
        }

        .point-item:hover {
            transform: translateX(-5px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .point-coords {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            color: #4a5568;
        }

        .delete-btn {
            background: #e53e3e;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            width: auto;
            margin: 0;
        }

        .delete-btn:hover {
            background: #c53030;
            transform: scale(1.05);
        }

        .clear-btn {
            background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%);
            margin-bottom: 20px;
        }

        .clear-btn:hover {
            box-shadow: 0 10px 25px rgba(229, 62, 62, 0.3);
        }

        .model-options {
            margin-top: 20px;
        }

        select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.8);
            margin-bottom: 15px;
        }

        .color-input {
            width: 100%;
            height: 50px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            cursor: pointer;
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .instructions {
            background: rgba(255, 248, 220, 0.9);
            border: 2px solid #d69e2e;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 14px;
            line-height: 1.6;
        }

        .status {
            text-align: center;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-weight: 500;
        }

        .status.success {
            background: rgba(72, 187, 120, 0.1);
            color: #2f855a;
            border: 1px solid rgba(72, 187, 120, 0.3);
        }

        .status.error {
            background: rgba(229, 62, 62, 0.1);
            color: #c53030;
            border: 1px solid rgba(229, 62, 62, 0.3);
        }

        .preset-section {
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 12px;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }

        .preset-btn {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            margin-bottom: 10px;
        }

        .preset-btn:hover {
            box-shadow: 0 10px 25px rgba(72, 187, 120, 0.3);
        }

        .cylinder-params {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .param-label {
            font-size: 12px;
            margin-bottom: 5px;
            color: #4a5568;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="control-panel">
            <h1>יוצר מודל תלת מימדי</h1>
            
            <div class="preset-section">
                <label>דוגמאות מוכנות:</label>
                <button class="preset-btn" onclick="createCurvedCylinder()">גליל עקום חדש</button>
                <div class="cylinder-params">
                    <div>
                        <div class="param-label">אורך הגליל:</div>
                        <input type="number" id="cylinder-length" value="10" min="5" max="20">
                    </div>
                    <div>
                        <div class="param-label">עוצמת עקמומיות:</div>
                        <input type="number" id="curve-strength" value="3" min="1" max="8" step="0.5">
                    </div>
                </div>
                <button class="preset-btn" onclick="createSpiral()">ספירלה תלת מימדית</button>
                <button class="preset-btn" onclick="resetToIsometricView()">איפוס לתצוגה איזומטרית</button> 
                <button class="preset-btn" onclick="saveCurrentView()">שמירת תצוגה נוכחית</button> 
            </div>

            <div id="status" class="status" style="display: none;"></div>

            <div class="input-group">
                <label>קואורדינטות נקודה חדשה:</label>
                <div class="input-labels">
                    <div>X</div>
                </div>
                <div class="coordinate-inputs">
                    <input type="number" id="x-coord" placeholder="0" step="0.1">
                </div>
                <!-- Swapped Y and Z input positions in the UI -->
                <div class="input-labels">
                    <div>Y</div>
                </div>
                <div class="coordinate-inputs">
                    <input type="number" id="z-coord" placeholder="0" step="0.1"> <!-- This input is for user's Y (depth) -->
                </div>
                <div class="input-labels">
                    <div>Z</div>
                </div>
                <div class="coordinate-inputs">
                    <input type="number" id="y-coord" placeholder="0" step="0.1"> <!-- This input is for user's Z (height) -->
                </div>
            </div>

            <button onclick="addPoint()">הוסף נקודה</button>

            <div class="model-options">
                <label>סוג המודל:</label>
                <select id="model-type" onchange="updateModel()">
                    <option value="points">נקודות</option>
                    <option value="lines" selected>קווים מחברים</option>
                    <option value="mesh">רשת משולשים</option>
                    <option value="wireframe">מסגרת תיל</option>
                    <option value="tube">צינור תלת מימדי</option>
                </select>

                <label>צבע המודל:</label>
                <input type="color" id="model-color" value="#667eea" onchange="updateModel()" class="color-input">
            </div>

            <button onclick="clearAll()" class="clear-btn">נקה הכל</button>

            <div class="input-group">
                <label>נקודות קיימות (<span id="point-count">0</span>):</label>
                <div id="point-list" class="point-list">
                    <div style="text-align: center; color: #718096; font-style: italic;">
                        אין נקודות עדיין
                    </div>
                </div>
            </div>
        </div>

        <div class="viewer">
            <canvas id="canvas"></canvas>
        </div>
    </div>

    <script>
        // Global variables for Three.js scene, camera, renderer, and points data
        let scene, perspectiveCamera, renderer; 
        let points = [];
        let currentModel = null;

        // Variables for custom camera controls (rotation and zoom)
        let mouseDown = false;
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0.3; // Target pitch rotation
        let targetRotationY = 0.5; // Target yaw rotation
        let currentRotationX = 0.3; // Current smooth pitch rotation
        let currentRotationY = 0.5; // Current smooth yaw rotation

        /**
         * Initializes the Three.js scene, sets up cameras, renderer, lighting,
         * grid, axes, custom controls, and handles window resizing.
         * Creates an initial curved cylinder model on load.
         */
        function init() {
            // Scene: where all objects, lights, and cameras are located.
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a202c); // Set a dark background for better contrast

            // Perspective Camera: the main camera for realistic 3D viewing.
            // Parameters: Field of View (FoV), Aspect Ratio, Near clipping plane, Far clipping plane.
            perspectiveCamera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            perspectiveCamera.position.set(15, 10, 15); // Initial position for a good view
            perspectiveCamera.lookAt(0, 0, 0); // Point camera at the origin
            // Set Three.js Y-axis as the "up" direction for the perspective camera,
            // aligning with the user's intended Z-axis (height).
            perspectiveCamera.up = new THREE.Vector3(0, 1, 0); 

            // Renderer: displays the scene on the canvas element.
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialiasing: true }); // Enable antialiasing for smoother edges
            renderer.setSize(canvas.clientWidth, canvas.clientHeight); // Set renderer size to match canvas dimensions
            renderer.shadowMap.enabled = true; // Enable shadow mapping for more realistic lighting
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Use softer shadows

            // Lighting: illuminates the scene.
            // Ambient light: provides a general, uniform illumination, no shadows.
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            // Directional light: simulates light from a distant source like the sun, objects cast shadows.
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5); // Position of the light source
            directionalLight.castShadow = true; // Enable shadow casting
            scene.add(directionalLight);

            // Point light: emits light from a single point in all directions.
            const pointLight = new THREE.PointLight(0x667eea, 0.6); // Blueish light
            pointLight.position.set(-10, 10, -10); // Position of the point light
            scene.add(pointLight);

            // Grid Helper: a visual aid for orientation and scale in the 3D space.
            // Parameters: size, divisions, center line color, grid line color.
            const gridHelper = new THREE.GridHelper(30, 30, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Axes Helper: a visual aid for X, Y, Z axes.
            const axesHelper = new THREE.AxesHelper(8); // Size of the axes
            scene.add(axesHelper);

            // Add axis labels using sprites to clarify the coordinate system
            addAxisLabels();

            // Set up custom mouse controls for camera interaction
            setupControls();

            // Event listener for window resizing to adjust renderer and camera aspect ratio
            window.addEventListener('resize', onWindowResize);
            
            // Create an initial curved cylinder model when the application starts
            createCurvedCylinder();
            
            // Start the main animation loop
            animate();
        }

        /**
         * Adds X, Y, Z axis labels to the scene using THREE.Sprite.
         * Sprites are 2D planes that always face the camera.
         */
        function addAxisLabels() {
            // X axis label (red) - remains the standard horizontal axis
            const xLabel = createTextSprite('X', '#ff0000');
            xLabel.position.set(9, 0, 0); 
            scene.add(xLabel);
            
            // User's Z-axis (height) corresponds to Three.js Y-axis (green).
            // So, the label 'Z' is placed along the green axis.
            const zLabel = createTextSprite('Z', '#00ff00'); // Label 'Z', color green
            zLabel.position.set(0, 9, 0); // Position on the Three.js Y-axis
            scene.add(zLabel);

            // User's Y-axis (depth) corresponds to Three.js Z-axis (blue).
            // So, the label 'Y' is placed along the blue axis.
            const yLabel = createTextSprite('Y', '#0000ff'); // Label 'Y', color blue
            yLabel.position.set(0, 0, 9); // Position on the Three.js Z-axis
            scene.add(yLabel);
        }

        /**
         * Creates a 2D text sprite using a canvas to draw the text.
         * This sprite can then be added to the Three.js scene.
         * @param {string} text - The text content for the sprite.
         * @param {string} color - The color of the text (e.g., '#RRGGBB').
         * @returns {THREE.Sprite} The created Three.js Sprite object.
         */
        function createTextSprite(text, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            // Set canvas size (powers of 2 are generally good for textures for performance)
            canvas.width = 128;
            canvas.height = 128;
            
            // Set font properties and text alignment for drawing on the canvas
            context.font = 'Bold 48px Arial';
            context.fillStyle = color;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Draw the text onto the canvas, centered
            context.fillText(text, 64, 64); 
            
            // Create a Three.js texture from the canvas content
            const texture = new THREE.CanvasTexture(canvas);
            
            // Create a sprite material using the texture
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            
            // Create the sprite object and set its scale in the 3D scene
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(4, 4, 1); // Increased scale for better visibility
            
            return sprite;
        }

        /**
         * Sets up custom mouse and wheel controls for orbiting the camera.
         * These controls only affect the perspective camera.
         */
        function setupControls() {
            const canvas = document.getElementById('canvas');

            // Mouse down event: set flag and record initial mouse position
            canvas.addEventListener('mousedown', (event) => {
                // Controls are always active on the perspective camera now
                mouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            // Mouse up event: reset flag
            canvas.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            // Mouse move event: update target rotation based on mouse movement
            canvas.addEventListener('mousemove', (event) => {
                // Update rotation if mouse is down
                if (mouseDown) { 
                    const deltaX = event.clientX - mouseX; // Horizontal movement
                    const deltaY = event.clientY - mouseY; // Vertical movement
                    
                    targetRotationY += deltaX * 0.01; // Adjust yaw (rotation around Y-axis, which is user's Z)
                    targetRotationX += deltaY * 0.01; // Adjust pitch (rotation around X-axis)
                    
                    // Clamp pitch rotation to prevent the camera from flipping upside down
                    targetRotationX = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, targetRotationX));

                    mouseX = event.clientX; // Update last mouse position
                    mouseY = event.clientY;
                }
            });

            // Wheel event: zoom in/out by adjusting the perspective camera's distance from origin
            canvas.addEventListener('wheel', (event) => {
                const factor = 1 + event.deltaY * 0.001; // Adjust zoom factor based on wheel direction
                // Multiply camera position by factor, clamping to a reasonable range
                perspectiveCamera.position.multiplyScalar(Math.max(0.5, Math.min(3, factor)));
            });

            /**
             * Smoothly updates perspective camera rotation towards target values.
             * Called continuously in the animation loop.
             */
            function updateControls() {
                // Apply rotation smoothing
                currentRotationX += (targetRotationX - currentRotationX) * 0.1;
                currentRotationY += (targetRotationY - currentRotationY) * 0.1;
                
                // Recalculate perspective camera position using spherical coordinates.
                // This maps the user's (X, Y_depth, Z_height) to Three.js's (X, Y_height, Z_depth).
                const radius = perspectiveCamera.position.length(); 
                perspectiveCamera.position.x = radius * Math.cos(currentRotationX) * Math.sin(currentRotationY);
                perspectiveCamera.position.y = radius * Math.sin(currentRotationX); // Three.js Y is our vertical axis (user's Z)
                perspectiveCamera.position.z = radius * Math.cos(currentRotationX) * Math.cos(currentRotationY);
                
                // Make the camera always look at the origin (0,0,0)
                perspectiveCamera.lookAt(0, 0, 0); 
                
                // Request the next animation frame for continuous smooth animation
                requestAnimationFrame(updateControls);
            }
            updateControls(); // Start the control update loop
        }

        /**
         * Handles window resize events.
         * Updates camera aspect ratio and renderer size to fit the new window dimensions.
         */
        function onWindowResize() {
            const canvas = document.getElementById('canvas');
            const aspect = canvas.clientWidth / canvas.clientHeight;

            // Update perspective camera's aspect ratio and projection matrix
            if (perspectiveCamera) {
                perspectiveCamera.aspect = aspect;
                perspectiveCamera.updateProjectionMatrix();
            }
            
            // Resize the renderer to match the new canvas size
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        }

        /**
         * Main animation loop.
         * Requests the next frame and renders the scene using the currently active camera.
         */
        function animate() {
            requestAnimationFrame(animate); // Loop continuously for animation
            renderer.render(scene, perspectiveCamera); // Always render with the perspectiveCamera
        }

        /**
         * Creates a 3D curved cylinder by generating a series of points
         * that define its path.
         * The length and curve strength are read from the input fields.
         */
        function createCurvedCylinder() {
            // Read length and curve strength from input fields, with fallbacks to default values
            const length = parseFloat(document.getElementById('cylinder-length').value) || 10;
            const curveStrength = parseFloat(document.getElementById('curve-strength').value) || 3;
            
            points = []; // Clear any existing points in the array

            // Generate points along a path to form a curved cylinder shape
            for (let i = 0; i <= length * 2; i++) {
                const t = i / (length * 2); // Normalized parameter (0 to 1) along the path
                const x_calc = t * length - length / 2; // Linear progression along the X-axis
                // Calculate original Y and Z based on mathematical formulas for the curve
                const y_calc = Math.sin(t * Math.PI * 2) * curveStrength + Math.cos(t * Math.PI * 3) * (curveStrength * 0.5);
                const z_calc = Math.cos(t * Math.PI * 1.5) * (curveStrength * 0.7);
                
                // Store points in user's coordinate system: X (horizontal), Y (depth), Z (height)
                // Note the swap: original Y_calc becomes user's Z (height), original Z_calc becomes user's Y (depth)
                points.push({ x: parseFloat(x_calc.toFixed(2)), y: parseFloat(z_calc.toFixed(2)), z: parseFloat(y_calc.toFixed(2)) });
            }
            
            updatePointList(); // Refresh the displayed list of points in the UI
            updateModel();     // Update the 3D model in the scene based on new points
            showStatus(`נוצר גליל עקום עם ${points.length} נקודות (אורך: ${length}, עקמומיות: ${curveStrength})`, 'success');
        }

        /**
         * Creates a 3D spiral by generating points that expand outwards
         * as they rise.
         */
        function createSpiral() {
            points = []; // Clear any existing points
            
            // Generate points for a 3D spiral shape
            for (let i = 0; i <= 100; i++) {
                const t = i / 10; // Parameter for progression along the spiral
                const radius = 2 + t * 0.1; // Radius increases over time, making the spiral wider
                const x_calc = Math.cos(t) * radius; 
                const y_calc = t * 0.5; // Original Y increases linearly for height
                const z_calc = Math.sin(t) * radius; // Original Z for the circle component
                
                // Store points in user's coordinate system: X, Y (depth), Z (height)
                // Note the swap: original Y_calc becomes user's Z (height), original Z_calc becomes user's Y (depth)
                points.push({ x: parseFloat(x_calc.toFixed(2)), y: parseFloat(z_calc.toFixed(2)), z: parseFloat(y_calc.toFixed(2)) });
            }
            
            updatePointList(); // Refresh the displayed list of points
            updateModel();     // Update the 3D model in the scene
            showStatus(`נוצרה ספירלה תלת מימדית עם ${points.length} נקודות`, 'success');
        }

        /**
         * Adds a new point to the `points` array based on user input
         * from the X, Y, Z coordinate fields in the UI.
         * Clears the input fields after adding the point.
         */
        function addPoint() {
            // Parse float values from input fields, defaulting to 0 if invalid input
            const x = parseFloat(document.getElementById('x-coord').value) || 0;
            // Read user's Y (depth) from the input field with ID 'z-coord' (as Y and Z were swapped in UI)
            const user_y_depth = parseFloat(document.getElementById('z-coord').value) || 0; 
            // Read user's Z (height) from the input field with ID 'y-coord' (as Y and Z were swapped in UI)
            const user_z_height = parseFloat(document.getElementById('y-coord').value) || 0; 

            // Store the new point in the `points` array using the user's coordinate system
            points.push({ x: x, y: user_y_depth, z: user_z_height }); 
            
            // Display a success message to the user
            showStatus(`נוספה נקודה: (${x}, ${user_y_depth}, ${user_z_height})`, 'success'); 
            
            // Clear input fields after adding the point for next entry
            document.getElementById('x-coord').value = '';
            document.getElementById('y-coord').value = '';
            document.getElementById('z-coord').value = '';

            updatePointList(); // Update the displayed list of points in the UI
            updateModel();     // Update the 3D model in the scene
        }

        /**
         * Updates the HTML list displaying the current points and the point count.
         */
        function updatePointList() {
            const listElement = document.getElementById('point-list');
            const countElement = document.getElementById('point-count');
            
            countElement.textContent = points.length; // Update the displayed point count
            
            // If there are no points, display a specific message
            if (points.length === 0) {
                listElement.innerHTML = '<div style="text-align: center; color: #718096; font-style: italic;">אין נקודות עדיין</div>';
                return;
            }

            // Generate HTML for each point and add it to the list, with a delete button
            listElement.innerHTML = points.map((point, index) => `
                <div class="point-item">
                    <span class="point-coords">(${point.x}, ${point.y}, ${point.z})</span>
                    <button class="delete-btn" onclick="removePoint(${index})">מחק</button>
                </div>
            `).join('');
        }

        /**
         * Removes a point from the `points` array at the specified index.
         * Updates the point list and the 3D model after removal.
         * @param {number} index - The index of the point to remove.
         */
        function removePoint(index) {
            points.splice(index, 1); // Remove 1 element from the array at the given index
            updatePointList();       // Refresh the displayed list
            updateModel();           // Refresh the 3D model in the scene
            showStatus('נקודה נמחקה', 'success'); // Show confirmation message
        }

        /**
         * Clears all points from the `points` array,
         * then updates the point list and the 3D model to reflect the empty state.
         */
        function clearAll() {
            points = []; // Empty the points array
            updatePointList(); // Clear the displayed list of points
            updateModel();     // Clear the 3D model from the scene
            showStatus('כל הנקודות נמחקו', 'success'); // Show confirmation message
        }

        /**
         * Updates the 3D model displayed in the scene based on the current
         * `points` array, selected `model-type` (e.g., points, lines, tube, mesh, wireframe),
         * and `model-color`. Removes the previous model before adding the new one.
         */
        function updateModel() {
            // Remove the existing model from the scene if it exists, and dispose of its resources
            if (currentModel) {
                scene.remove(currentModel);
                currentModel.geometry.dispose(); // Dispose geometry to free up memory
                if (currentModel.material) {
                    if (Array.isArray(currentModel.material)) {
                        currentModel.material.forEach(m => m.dispose()); // Dispose each material if it's an array
                    } else {
                        currentModel.material.dispose(); // Dispose single material
                    }
                }
                currentModel = null;
            }

            // If there are no points, simply return as there's nothing to render
            if (points.length === 0) return;

            const modelType = document.getElementById('model-type').value; // Get selected model type from UI
            const color = new THREE.Color(document.getElementById('model-color').value); // Get selected color from UI

            // Create a BufferGeometry to hold the vertex data
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            
            // Iterate through the user's points and add them to the vertices array.
            // Map user's (X, Y_depth, Z_height) to Three.js's (X, Y_height, Z_depth)
            points.forEach(point => {
                // Three.js X = user's X (point.x)
                // Three.js Y = user's Z (height) (point.z)
                // Three.js Z = user's Y (depth) (point.y)
                vertices.push(point.x, point.z, point.y); 
            });
            
            // Set the position attribute of the geometry
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));

            // Create the appropriate 3D object based on the selected model type
            switch (modelType) {
                case 'points':
                    // Display individual points as a point cloud
                    const pointsMaterial = new THREE.PointsMaterial({ 
                        color: color, 
                        size: 0.3, // Size of each point in the scene
                        sizeAttenuation: true // Points appear smaller when further away from the camera
                    });
                    currentModel = new THREE.Points(geometry, pointsMaterial);
                    break;
                
                case 'lines':
                    // Connect points with lines (requires at least 2 points to draw a line)
                    if (points.length > 1) {
                        const linesMaterial = new THREE.LineBasicMaterial({ color: color, linewidth: 3 }); // Line thickness (may not be universally supported by all GPU drivers)
                        currentModel = new THREE.Line(geometry, linesMaterial);
                    }
                    break;
                
                case 'tube':
                    // Create a smooth tube along the path of points (requires at least 3 points for a meaningful curve)
                    if (points.length > 2) {
                        // Create curve points in Three.js coordinate system (X, Y_height, Z_depth)
                        const curvePoints = points.map(p => new THREE.Vector3(p.x, p.z, p.y)); 
                        const curve = new THREE.CatmullRomCurve3(curvePoints); // Creates a smooth spline curve interpolation
                        // TubeGeometry parameters: curve, segments along curve, radius of tube, radial segments for tube circle, closed (is the tube a loop)
                        const tubeGeometry = new THREE.TubeGeometry(curve, points.length * 2, 0.2, 8, false);
                        const tubeMaterial = new THREE.MeshLambertMaterial({ 
                            color: color,
                            transparent: true,
                            opacity: 0.9 // Slightly transparent for a glass-like effect
                        });
                        currentModel = new THREE.Mesh(tubeGeometry, tubeMaterial);
                        currentModel.castShadow = true; // Make the tube cast shadows
                        currentModel.receiveShadow = true; // Make the tube receive shadows
                    }
                    break;
                
                case 'mesh':
                    // Create a basic triangulated mesh (requires at least 3 points to form a face)
                    if (points.length >= 3) {
                        const indices = [];
                        // Simple fan triangulation: connects the first point to all other consecutive pairs
                        // This works for convex shapes, but might not be ideal for complex point sets.
                        for (let i = 1; i < points.length - 1; i++) {
                            indices.push(0, i, i + 1);
                        }
                        geometry.setIndex(indices); // Set vertex indices for faces
                        geometry.computeVertexNormals(); // Calculate normals for correct lighting
                        
                        const meshMaterial = new THREE.MeshLambertMaterial({ 
                            color: color, 
                            side: THREE.DoubleSide, // Render both front and back sides of the faces
                            transparent: true,
                            opacity: 0.8
                        });
                        currentModel = new THREE.Mesh(geometry, meshMaterial);
                        currentModel.castShadow = true; // Make the mesh cast shadows
                    }
                    break;
                
                case 'wireframe':
                    // Create a wireframe representation of the mesh (requires at least 3 points)
                    if (points.length >= 3) {
                        const indices = [];
                        // Generate indices for wireframe lines (each edge is defined by two vertices)
                        for (let i = 1; i < points.length - 1; i++) {
                            // Defines edges for a triangular fan: (0-i), (i-i+1), (i+1-0)
                            indices.push(0, i, i, i + 1, i + 1, 0);
                        }
                        geometry.setIndex(indices);
                        
                        const wireframeMaterial = new THREE.LineBasicMaterial({ color: color });
                        currentModel = new THREE.LineSegments(geometry, wireframeMaterial); // Renders lines only
                    }
                    break;
            }

            // Add the newly created model to the scene if it was successfully created
            if (currentModel) {
                scene.add(currentModel);
            }
        }

        /**
         * Displays a temporary status message to the user in the UI.
         * @param {string} message - The message content to display.
         * @param {'success'|'error'} type - The type of message (determines styling, e.g., green for success, red for error).
         */
        function showStatus(message, type) {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`; // Apply styling based on type
            statusElement.style.display = 'block'; // Make the status message visible
            
            // Hide the status message after 3 seconds
            setTimeout(() => {
                statusElement.style.display = 'none';
            }, 3000);
        }

        /**
         * Resets the perspective camera to a standard isometric view and updates controls.
         * This effectively sets a new "starting point" for interactive camera controls.
         */
        function resetToIsometricView() {
            // Define the target isometric position in Three.js coordinates (X, Y_height, Z_depth)
            const isoX = 20;
            const isoY_height = 20; // Corresponds to user's Z
            const isoZ_depth = 20;  // Corresponds to user's Y

            perspectiveCamera.position.set(isoX, isoY_height, isoZ_depth);
            perspectiveCamera.lookAt(0, 0, 0); // Always look at the origin
            
            // Recalculate targetRotationX and targetRotationY based on the new camera position
            const radius = perspectiveCamera.position.length();
            targetRotationX = Math.asin(perspectiveCamera.position.y / radius); // Pitch based on Three.js Y
            targetRotationY = Math.atan2(perspectiveCamera.position.x, perspectiveCamera.position.z); // Yaw based on Three.js X, Z

            // Immediately update current rotation to match target for a smooth transition from this point
            currentRotationX = targetRotationX;
            currentRotationY = targetRotationY;

            showStatus('הוגדר מצב איזומטרי כנקודת אתחול', 'success');
        }

        /**
         * Saves a screenshot of the current 3D scene view.
         * It captures what is currently rendered on the canvas.
         */
        function saveCurrentView() {
            const canvas = document.getElementById('canvas');
            
            // Explicitly render one frame to ensure the canvas content is up-to-date
            // before capturing the image.
            renderer.render(scene, perspectiveCamera);

            const imageDataURL = renderer.domElement.toDataURL('image/png'); // Get image data directly from canvas

            // Trigger download of the image
            const link = document.createElement('a');
            link.download = 'model_current_view.png'; // Changed filename
            link.href = imageDataURL;
            link.click();
            link.remove(); // Clean up the temporary link element

            showStatus('תמונת המודל הנוכחית נשמרה!', 'success'); // Updated status message
        }

        // Event listener for 'Enter' key press on coordinate input fields
        document.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                const activeElement = document.activeElement; // Get the currently focused HTML element
                // If the focused element is one of the coordinate input fields, trigger addPoint()
                if (activeElement && activeElement.id && activeElement.id.includes('coord')) {
                    addPoint();
                }
            }
        });

        // Initialize the 3D application once the window has fully loaded all resources
        window.onload = function () {
            init(); 
        }
    </script>
</body>
</html>
